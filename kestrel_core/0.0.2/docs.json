{
  "version": "0.0.2",
  "modules": {
    "Async": {
      "moduleName": "Async",
      "items": [
        {
          "type": "value",
          "name": "both",
          "signature": "(Task<a>, Task<b>) -> Task<(a, b)>",
          "docComment": " Run the two tasks concurrently and collect the results.\n\n ```kestrel\n pub let main = {\n   let#await (a, b) = Async.both(\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(1000), fn _ {\n       1\n     }),\n   );\n   // Resolves with a=0 and b=1\n   // in 1 second instead of 2\n   Task.none\n }\n ```\n"
        },
        {
          "type": "value",
          "name": "all",
          "signature": "(List<Task<a>>) -> Task<List<a>>",
          "docComment": " Like [both](#both), but for more than two tasks\n"
        },
        {
          "type": "value",
          "name": "both_ok",
          "signature": "(Task<Result<a, b>>, Task<Result<c, b>>) -> Task<Result<(a, c), b>>",
          "docComment": " Run the two `Task`s concurrently.\n Return `Ok` if both `Task`s succeeed, otherwise return `Err` with the first task that fails, and cancel the other.\n"
        },
        {
          "type": "value",
          "name": "all_ok",
          "signature": "(List<Task<Result<a, b>>>) -> Task<Result<List<a>, b>>",
          "docComment": " Like [both_ok](#both_ok), but for more than two tasks\n"
        },
        {
          "type": "value",
          "name": "race",
          "signature": "(List<Task<a>>) -> Task<a>",
          "docComment": " Run the tasks concurrently and yield the value of the first `Task` to complete.\n All the other tasks are cancelled.\n\n ```kestrel\n pub let main = {\n   let#await a = Async.race([\n     Task.map(Task.sleep(1000), fn _ {\n       0\n     }),\n     Task.map(Task.sleep(200), fn _ {\n       1\n     }),\n   ]);\n   // Resolves with a=1 in 200ms\n   Task.none\n }\n ```\n"
        }
      ],
      "moduleDoc": " This module contains a bunch of utilities for handling concurrency operations\n"
    },
    "List": {
      "moduleName": "List",
      "items": [
        {
          "type": "adt",
          "name": "List",
          "params": [
            "a"
          ],
          "docComment": " This type represents a singly linked list\n",
          "variants": [
            {
              "name": "Nil",
              "args": []
            },
            {
              "name": "Cons",
              "args": [
                "a",
                "List<a>"
              ]
            }
          ]
        },
        {
          "type": "value",
          "name": "range",
          "signature": "(Int, Int) -> List<Int>",
          "docComment": " `range(a, b)` is a list from `a` to `b` exclusive\n \n ```kestrel\n range(0, 3) // => [0, 1, 2]\n ```\n"
        },
        {
          "type": "value",
          "name": "map",
          "signature": "(List<a>, (a) -> b) -> List<b>",
          "docComment": " Applies the given function to every element of the list, and return a new list\n with the mapped elements.\n It takes `O(n)` time\n \n ```kestrel\n map([1, 2, 3], fn x { x * 10 }) // => [10, 20, 30]\n ```\n"
        },
        {
          "type": "value",
          "name": "filter",
          "signature": "(List<a>, (a) -> Bool) -> List<a>",
          "docComment": " Returns a new list containing only the elements that match the given predicate, in the same order\n It takes `O(n)` time\n \n ```kestrel\n filter(['a', 'b', 'c'], fn x { x == 'b' }) // => ['b']\n ````\n"
        },
        {
          "type": "value",
          "name": "map2",
          "signature": "(List<a>, List<b>, (a, b) -> c) -> List<c>"
        },
        {
          "type": "value",
          "name": "find",
          "signature": "(List<a>, (a) -> Bool) -> Option<a>"
        },
        {
          "type": "value",
          "name": "reduce",
          "signature": "(List<a>, b, (b, a) -> b) -> b"
        },
        {
          "type": "value",
          "name": "reduce_right",
          "signature": "(List<a>, b, (a, b) -> b) -> b"
        },
        {
          "type": "value",
          "name": "concat",
          "signature": "(List<a>, List<a>) -> List<a>"
        },
        {
          "type": "value",
          "name": "sum_ints",
          "signature": "(List<Int>) -> Int"
        },
        {
          "type": "value",
          "name": "flatten",
          "signature": "(List<List<a>>) -> List<a>"
        },
        {
          "type": "value",
          "name": "flat_map",
          "signature": "(List<a>, (a) -> List<b>) -> List<b>"
        },
        {
          "type": "value",
          "name": "filter_map",
          "signature": "(List<a>, (a) -> Option<b>) -> List<b>"
        },
        {
          "type": "value",
          "name": "take",
          "signature": "(List<a>, Int) -> List<a>"
        },
        {
          "type": "value",
          "name": "drop",
          "signature": "(List<a>, Int) -> List<a>"
        },
        {
          "type": "value",
          "name": "is_empty",
          "signature": "(List<a>) -> Bool"
        },
        {
          "type": "value",
          "name": "length",
          "signature": "(List<a>) -> Int"
        },
        {
          "type": "value",
          "name": "zip",
          "signature": "(List<a>, List<b>) -> List<(a, b)>"
        },
        {
          "type": "value",
          "name": "reverse",
          "signature": "(List<a>) -> List<a>",
          "docComment": " Reverse a list.\n"
        },
        {
          "type": "value",
          "name": "guard",
          "signature": "(Bool, (Unit) -> List<a>) -> List<a>",
          "docComment": " This function is meant to be used with `let#` syntax\n ```kestrel\n {\n   let#List.flat_map x = [1, 2];\n   let#List.flat_map y = ['a', 'b'];\n   let#List.guard _unit = x == 1;\n   [(x, y)]\n }\n ```\n"
        },
        {
          "type": "value",
          "name": "includes",
          "signature": "(List<a>, a) -> Bool",
          "docComment": " Returns True wheter a list contains the given value.\n `==` is used to match the item\n"
        }
      ]
    },
    "Bool": {
      "moduleName": "Bool",
      "items": [
        {
          "type": "adt",
          "name": "Bool",
          "params": [],
          "docComment": " A boolean value that can either be `True` or `False`.\n \n Note that this isn't a builtin type, but a regular union type\n",
          "variants": [
            {
              "name": "True",
              "args": []
            },
            {
              "name": "False",
              "args": []
            }
          ]
        },
        {
          "type": "value",
          "name": "&&",
          "signature": "(Bool, Bool) -> Bool",
          "docComment": " Logic `and` between booleans\n \n ```kestrel\n True && True // => True\n True && False // => False\n False && True // => False\n False && False // => False\n ```\n"
        },
        {
          "type": "value",
          "name": "||",
          "signature": "(Bool, Bool) -> Bool",
          "docComment": " Logic `or` between booleans\n \n ```kestrel\n True || True // => True\n True || False // => True\n False || True // => True\n False || False // => False\n ```\n"
        },
        {
          "type": "value",
          "name": "!",
          "signature": "(Bool) -> Bool",
          "docComment": " Logic `not`\n \n ```kestrel\n !True // => False\n !False // => True\n ```\n"
        },
        {
          "type": "value",
          "name": "==",
          "signature": "(a, a) -> Bool",
          "docComment": " Perform structural equality between values.\n \n Requires values to implement the `Eq` trait, therefore\n equality is only supported for values of type:\n * `Int`\n * `Float`\n * `Char`\n * `String`\n * Union types whose constructors arguments support equality\n \n This mean that equality is supported, for example, for values of type `List<(String, Char)>`\n \n Equality between all the other values (for example functions or internal opaque types)\n is forbidden by the type system\n"
        },
        {
          "type": "value",
          "name": "!=",
          "signature": "(a, a) -> Bool",
          "docComment": " Same as `==`, but with negation\n"
        },
        {
          "type": "value",
          "name": ">",
          "signature": "(a, a) -> Bool"
        },
        {
          "type": "value",
          "name": ">=",
          "signature": "(a, a) -> Bool"
        },
        {
          "type": "value",
          "name": "<",
          "signature": "(a, a) -> Bool"
        },
        {
          "type": "value",
          "name": "<=",
          "signature": "(a, a) -> Bool"
        }
      ]
    },
    "Int": {
      "moduleName": "Int",
      "items": [
        {
          "type": "adt",
          "name": "Int",
          "params": [],
          "docComment": " An integer number\n"
        },
        {
          "type": "value",
          "name": "+",
          "signature": "(Int, Int) -> Int",
          "docComment": " Add two ints\n"
        },
        {
          "type": "value",
          "name": "-",
          "signature": "(Int, Int) -> Int",
          "docComment": " Substract two ints\n"
        },
        {
          "type": "value",
          "name": "*",
          "signature": "(Int, Int) -> Int",
          "docComment": " Multiply two ints\n"
        },
        {
          "type": "value",
          "name": "/",
          "signature": "(Int, Int) -> Int",
          "docComment": " Divide two ints\n"
        },
        {
          "type": "value",
          "name": "^",
          "signature": "(Int, Int) -> Int",
          "docComment": " Exponentiation\n \n ```kestrel\n 2 ^ 3 // => 8\n ```\n"
        },
        {
          "type": "value",
          "name": "%",
          "signature": "(Int, Int) -> Int",
          "docComment": " Modulo operator\n \n ```kestrel\n 10 % 2 // => 0\n 11 % 2 // => 1\n ```\n"
        }
      ]
    },
    "Option": {
      "moduleName": "Option",
      "items": [
        {
          "type": "adt",
          "name": "Option",
          "params": [
            "a"
          ],
          "docComment": " A type representing an value that might be either present (`Some`) or absent (`None`)\n",
          "variants": [
            {
              "name": "Some",
              "args": [
                "a"
              ]
            },
            {
              "name": "None",
              "args": []
            }
          ]
        },
        {
          "type": "value",
          "name": "map",
          "signature": "(Option<a>, (a) -> b) -> Option<b>",
          "docComment": " Maps the option's value using the given functions\n \n ```kestrel\n map(None, fn x { x + 1 }) // => None\n map(Some(42), fn x { x + 1 }) // => Some(43)\n ```\n"
        },
        {
          "type": "value",
          "name": "and_then",
          "signature": "(Option<a>, (a) -> Option<b>) -> Option<b>",
          "docComment": " Maps the option's value using the given functions, and flattens the results\n \n It holds the property `and_then(x, Some) == x`\n ```kestrel\n and_then(None, fn x { Some(42) }) // => None\n and_then(Some(42), fn x { None }) // => None\n and_then(Some(42), fn x { Some(x + 1) }) // => Some(43)\n ```\n"
        },
        {
          "type": "value",
          "name": "map2",
          "signature": "(Option<a>, Option<b>, (a, b) -> c) -> Option<c>",
          "docComment": " If both of the options are `Some`, maps their value using the\n given function. Else, returns `None`\n \n ```kestrel\n map2(None, None, fn a, b { a + b }) // => None\n map2(Some(42), None, fn a, b { a + b }) // => None\n map2(None, Some(42), fn a, b { a + b }) // => None\n map2(Some(1), Some(2), fn a, b { a + b }) // => Some(3)\n ```\n"
        },
        {
          "type": "value",
          "name": "map3",
          "signature": "(Option<a>, Option<b>, Option<c>, (a, b, c) -> d) -> Option<d>",
          "docComment": " Like `map2`, but with 3 options\n"
        },
        {
          "type": "value",
          "name": "with_default",
          "signature": "(Option<a>, a) -> a",
          "docComment": " Returns wrapped value when option is `Some`, else returns the default value\n \n ```kestrel\n with_default(Some(\"value\"), \"default value\") // => \"value\"\n with_default(None, \"default value\") // => \"default value\"\n ```\n"
        }
      ]
    },
    "Tuple": {
      "moduleName": "Tuple",
      "items": [
        {
          "type": "adt",
          "name": "Unit",
          "params": [],
          "docComment": " `Unit` is a `Tuple` with zero values. It only has one value: `Unit`\n Can be used in a similar way to `undefined` in javascript, to represent values that do not\n actually bring any meaningful information\n \n For example:\n * You can use the type `Result<Unit, String>` to represent values that can either fail (with a `String` error message)\n or succeed, without yielding any particular value. This is more idiomatic that representing error as `Maybe<String>`\n * You can use the type `Task<Unit>` to represent a computation the doesn't yield any value. This is actually the type required by the `main` value\n \n **note** if you are trying to represent a value that can either be of the type `T` or undefined, `Maybe<T>` might be what you are looking for.\n",
          "variants": [
            {
              "name": "Unit",
              "args": []
            }
          ]
        },
        {
          "type": "adt",
          "name": "Tuple2",
          "params": [
            "a",
            "b"
          ],
          "docComment": " A tuple containing 2 values\n",
          "variants": [
            {
              "name": "Tuple2",
              "args": [
                "a",
                "b"
              ]
            }
          ]
        },
        {
          "type": "value",
          "name": "first",
          "signature": "((a, b)) -> a"
        },
        {
          "type": "value",
          "name": "second",
          "signature": "((a, b)) -> b"
        },
        {
          "type": "adt",
          "name": "Tuple3",
          "params": [
            "a",
            "b",
            "c"
          ],
          "docComment": " A tuple containing 3 values\n",
          "variants": [
            {
              "name": "Tuple3",
              "args": [
                "a",
                "b",
                "c"
              ]
            }
          ]
        },
        {
          "type": "adt",
          "name": "Tuple4",
          "params": [
            "a",
            "b",
            "c",
            "d"
          ],
          "docComment": " A tuple containing 4 values\n",
          "variants": [
            {
              "name": "Tuple4",
              "args": [
                "a",
                "b",
                "c",
                "d"
              ]
            }
          ]
        }
      ],
      "moduleDoc": " The `Tuple` module contains tuples utilities.\n A sintax sugar for writing tuples is available,\n e.g. `(\"a\", \"b\")` will desugar to `Tuple.Tuple2(\"a\", \"b\")` when used as a value, whereas\n `(Int, Float)` will desguar to `Tuple.Tuple2<Int, Float>` when used as a type.\n"
    },
    "MVar": {
      "moduleName": "MVar",
      "items": [
        {
          "type": "adt",
          "name": "MVar",
          "params": [
            "a"
          ],
          "docComment": " A `MVar` is a synchronization primitive, useful for communicating from different forked tasks.\n Represents a mutable cell that can either be empty or filled with a value of type `a`.\n"
        },
        {
          "type": "value",
          "name": "empty",
          "signature": "Task<MVar<a>>",
          "docComment": " Create an empty `MVar`\n"
        },
        {
          "type": "value",
          "name": "put",
          "signature": "(MVar<a>, a) -> Task<Unit>",
          "docComment": " Put a value into the given `MVar`.\n If the `MVar` is filled, it will block until it is possible to put.\n"
        },
        {
          "type": "value",
          "name": "try_put",
          "signature": "(MVar<a>, a) -> Task<Bool>",
          "docComment": " A non-blocking version of `put`. Try putting the value into the MVar,\n returning `True` wheter the value was put, `False` otherwise.\n"
        },
        {
          "type": "value",
          "name": "put_async",
          "signature": "(MVar<a>, a) -> Task<Id>",
          "docComment": " Non-blocking version of `put`.\n Equivalent to wrapping a `put` inside a `Task.fork`\n"
        },
        {
          "type": "value",
          "name": "take",
          "signature": "(MVar<a>) -> Task<a>",
          "docComment": " Take the value from the given `MVar`.\n If the `MVar` is not filled, it will block until it is possible to take.\n"
        },
        {
          "type": "value",
          "name": "try_take",
          "signature": "(MVar<a>) -> Task<Option<a>>",
          "docComment": " A non-blocking version of `take`.\n Returns `None` if the `MVar` was empty, `Option(a)` otherwise.\n \n Note: after `try_take` the value is empty\n"
        },
        {
          "type": "value",
          "name": "read",
          "signature": "(MVar<a>) -> Task<a>"
        },
        {
          "type": "value",
          "name": "try_read",
          "signature": "(MVar<a>) -> Task<Option<a>>"
        },
        {
          "type": "value",
          "name": "of",
          "signature": "(a) -> Task<MVar<a>>",
          "docComment": " Create a `MVar` filled with the given value.\n"
        },
        {
          "type": "value",
          "name": "update_returning",
          "signature": "(MVar<a>, (a) -> (b, a)) -> Task<b>"
        }
      ]
    },
    "Task": {
      "moduleName": "Task",
      "items": [
        {
          "type": "adt",
          "name": "Task",
          "params": [
            "a"
          ],
          "docComment": " A task represents a computation (either synchronous or asynchronous) that yiels a value of type `a`.\n Unlike javascript's `Promise`, creating a `Task` doesn't actually do anything.\n The only way to actually run the task is to assign it to the `main` function of the entrypoint module.\n\n Another difference from `Promise` is that `Task` doesn't encode failure:\n to represent a `Task` that might yield an error value you can use the `Task<Result<value, error>>` type.\n Also unlike `Promise`, a task might either be a synchronous operation or a microtask.\n"
        },
        {
          "type": "value",
          "name": "of",
          "signature": "(a) -> Task<a>",
          "docComment": " Lift a value into a `Task`.\n The resulting `Task` might be either synchronous or asynchronous (the behaviour is unspecified).\n"
        },
        {
          "type": "value",
          "name": "never",
          "signature": "Task<a>",
          "docComment": " A task that never resolves.\n"
        },
        {
          "type": "value",
          "name": "await",
          "signature": "(Task<a>, (a) -> Task<b>) -> Task<b>",
          "docComment": " Use the result of a `Task` to create a new `Task`. This function does not execute the `Task`, it only describes a new computation. It is the main primitive to (_sequentially_) chain computation.\n\n ```kestrel\n IO.readline\n |> Task.await(fn value {\n   IO.println(\"Input: \" ++ value)\n })\n ```\n"
        },
        {
          "type": "value",
          "name": "map",
          "signature": "(Task<a>, (a) -> b) -> Task<b>"
        },
        {
          "type": "value",
          "name": "map_err",
          "signature": "(Task<Result<a, b>>, (b) -> c) -> Task<Result<a, c>>",
          "docComment": " If task is a `Result`, map error value.\n Equivalent of composing `Task.map` and `Result.map_err`\n"
        },
        {
          "type": "value",
          "name": "sleep",
          "signature": "(Int) -> Task<Unit>",
          "docComment": " Pause the execution for the given number of milliseconds\n"
        },
        {
          "type": "adt",
          "name": "Id",
          "params": [],
          "docComment": " Identifier of a forked `Task`.\n"
        },
        {
          "type": "value",
          "name": "fork",
          "signature": "(Task<Unit>) -> Task<Id>",
          "docComment": " Run the given computation concurrently.\n The `Id` is returned synchronously, thus there is no way to receive data from the forked `Task` or wait for it to finish.\n In order to accomplish that, the `MVar` synchronization primitive is provided in the `MVar` module.\n\n `fork` is a low-level primitive and you probably might want to use the higher-level `Async` module to perform concurrent computation.\n"
        },
        {
          "type": "value",
          "name": "kill",
          "signature": "(Id) -> Task<Unit>",
          "docComment": " Kill the computation with the given `Id`. Cancellation will be propagated recursively though its forks and awaited tasks.\n For example:\n ```kestrel\n pub let main = {\n   let#await task_id = Task.fork({\n     let#await _unit = Task.sleep(2000);\n     Task.println(\"Finished sleeping\")\n   });\n   // Killing this computation prevents the\n   // message to be printed\n   Task.kill(task_id)\n }\n ```\n \n Killing a terminated computation is a noop.\n"
        },
        {
          "type": "value",
          "name": "await_ok",
          "signature": "(Task<Result<a, b>>, (a) -> Task<Result<c, b>>) -> Task<Result<c, b>>"
        },
        {
          "type": "value",
          "name": "none",
          "signature": "Task<Unit>",
          "docComment": " A task that does not do anything.\n Same as `Task.of(Unit)`.\n"
        },
        {
          "type": "value",
          "name": "discard",
          "signature": "(Task<a>) -> Task<Unit>"
        },
        {
          "type": "value",
          "name": "forever",
          "signature": "(Task<Unit>) -> Task<a>"
        }
      ]
    },
    "Result": {
      "moduleName": "Result",
      "items": [
        {
          "type": "adt",
          "name": "Result",
          "params": [
            "a",
            "err"
          ],
          "docComment": " A type representing a value that could be either succesful or not.\n",
          "variants": [
            {
              "name": "Ok",
              "args": [
                "a"
              ]
            },
            {
              "name": "Err",
              "args": [
                "err"
              ]
            }
          ]
        },
        {
          "type": "value",
          "name": "map",
          "signature": "(Result<a, b>, (a) -> c) -> Result<c, b>",
          "docComment": " Maps the result's `Ok` value using the given functions\n \n ```kestrel\n map(Ok(42), fn x { x + 1 }) // => Ok(43)\n map(Err(\"err\"), fn x { x + 1 }) // => Err(\"err\")\n ```\n"
        },
        {
          "type": "value",
          "name": "map_err",
          "signature": "(Result<a, b>, (b) -> c) -> Result<a, c>",
          "docComment": " Like [`Result.map`](#map), but applies to the `Err` value\n"
        },
        {
          "type": "value",
          "name": "and_then",
          "signature": "(Result<a, b>, (a) -> Result<c, b>) -> Result<c, b>",
          "docComment": " Maps the result's `Ok` value using the given functions, and flattens the results\n \n It holds the property `and_then(x, Ok) == x`\n ```kestrel\n and_then(Err(\"err\"), fn x { Ok(42) }) // => Err(\"err\")\n and_then(Err(\"err1\"), fn x { Err(\"err2\") }) // => Err(\"err2\")\n and_then(Ok(42), fn x { Err(\"err\") }) // => Err(\"err\")\n and_then(Ok(42), fn x { Ok(x + 1) }) // => Ok(43)\n ```\n"
        }
      ]
    },
    "Char": {
      "moduleName": "Char",
      "items": [
        {
          "type": "adt",
          "name": "Char",
          "params": [],
          "docComment": " A single `unicode` character.\n \n You can write chars with the `'` syntax, e.g. `'a'`\n (note the single quote, unlike in javascript)\n"
        },
        {
          "type": "value",
          "name": "to_code",
          "signature": "(Char) -> Int"
        },
        {
          "type": "value",
          "name": "from_code",
          "signature": "(Int) -> Char"
        },
        {
          "type": "value",
          "name": "is_lower",
          "signature": "(Char) -> Bool"
        },
        {
          "type": "value",
          "name": "is_upper",
          "signature": "(Char) -> Bool"
        },
        {
          "type": "value",
          "name": "is_alpha",
          "signature": "(Char) -> Bool"
        },
        {
          "type": "value",
          "name": "is_digit",
          "signature": "(Char) -> Bool"
        }
      ]
    },
    "Debug": {
      "moduleName": "Debug",
      "items": [
        {
          "type": "value",
          "name": "inspect",
          "signature": "(a) -> String",
          "docComment": " Convert any given value to a stringified version of it\n \n ```kestrel\n inspect(Just(42)) // => \"Just(42)\"\n ```\n"
        },
        {
          "type": "value",
          "name": "todo",
          "signature": "(String) -> a",
          "docComment": " You can use the `todo` function as a placeholder for future implementation.\n This will result in an runtime errors\n"
        },
        {
          "type": "value",
          "name": "log",
          "signature": "(a, String) -> a",
          "docComment": " `console.log` some value with a label, and return the value\n As this function performs side effects outside the `Task` type, it won't be available on production development\n ```kestrel\n let x = Debug.log(42, \"my number\")\n // this logs `my number: 42`\n // and returns `42`\n ```\n"
        }
      ],
      "moduleDoc": " Debugging utilities.\n \n This module is only meant to be used in development mode\n and it's not going to be supported in production mode\n"
    },
    "String": {
      "moduleName": "String",
      "items": [
        {
          "type": "adt",
          "name": "String",
          "params": [],
          "docComment": " A value representing an unicode string\n"
        },
        {
          "type": "value",
          "name": "++",
          "signature": "(String, String) -> String",
          "docComment": " Concatenate two strings\n \n ```kestrel\n \"abc\" ++ \"def\" // => \"abcdef\"\n ```\n"
        },
        {
          "type": "value",
          "name": "length",
          "signature": "(String) -> Int",
          "docComment": " Returns the length of the string.\n It takes `O(1)` time\n \n ```kestrel\n length(\"abc\") // => 3\n ```\n"
        },
        {
          "type": "value",
          "name": "char_at",
          "signature": "(String, Int) -> Option<Char>"
        },
        {
          "type": "value",
          "name": "split",
          "signature": "(String, String) -> List<String>"
        },
        {
          "type": "value",
          "name": "to_list",
          "signature": "(String) -> List<Char>"
        },
        {
          "type": "value",
          "name": "from_list",
          "signature": "(List<Char>) -> String"
        },
        {
          "type": "value",
          "name": "from_char",
          "signature": "(Char) -> String",
          "docComment": " Casts a `Char` into a `String`\n"
        },
        {
          "type": "value",
          "name": "cons",
          "signature": "(Char, String) -> String"
        },
        {
          "type": "value",
          "name": "parse_int",
          "signature": "(String) -> Option<Int>"
        },
        {
          "type": "value",
          "name": "from_int",
          "signature": "(Int) -> String"
        }
      ]
    },
    "Dict": {
      "moduleName": "Dict",
      "items": [
        {
          "type": "adt",
          "name": "Dict",
          "params": [
            "k",
            "v"
          ]
        },
        {
          "type": "value",
          "name": "empty",
          "signature": "Dict<a, b>"
        },
        {
          "type": "value",
          "name": "member",
          "signature": "(Dict<a, b>, a) -> Bool"
        },
        {
          "type": "value",
          "name": "get",
          "signature": "(Dict<a, b>, a) -> Option<b>"
        },
        {
          "type": "value",
          "name": "insert",
          "signature": "(Dict<a, b>, a, b) -> Dict<a, b>"
        },
        {
          "type": "value",
          "name": "is_empty",
          "signature": "(Dict<a, b>) -> Bool"
        },
        {
          "type": "value",
          "name": "reduce_right",
          "signature": "(Dict<a, b>, c, (a, b, c) -> c) -> c"
        },
        {
          "type": "value",
          "name": "size",
          "signature": "(Dict<a, b>) -> Int"
        },
        {
          "type": "value",
          "name": "to_list",
          "signature": "(Dict<a, b>) -> List<(a, b)>"
        }
      ]
    },
    "Float": {
      "moduleName": "Float",
      "items": [
        {
          "type": "adt",
          "name": "Float",
          "params": [],
          "docComment": " A floating point number.\n \n Infix operations that deal with `Float` follow the convention of having a trailing `.`\n This is necessary to distinguish them from `Int` operators\n"
        },
        {
          "type": "value",
          "name": "+.",
          "signature": "(Float, Float) -> Float",
          "docComment": " Add two floats\n"
        },
        {
          "type": "value",
          "name": "-.",
          "signature": "(Float, Float) -> Float",
          "docComment": " Substract two floats\n"
        },
        {
          "type": "value",
          "name": "*.",
          "signature": "(Float, Float) -> Float",
          "docComment": " Multiply two floats\n"
        },
        {
          "type": "value",
          "name": "/.",
          "signature": "(Float, Float) -> Float",
          "docComment": " Divide two floats\n"
        },
        {
          "type": "value",
          "name": "ceil",
          "signature": "(Float) -> Int"
        },
        {
          "type": "value",
          "name": "floor",
          "signature": "(Float) -> Int"
        },
        {
          "type": "value",
          "name": "from_int",
          "signature": "(Int) -> Float"
        }
      ]
    },
    "IO": {
      "moduleName": "IO",
      "items": [
        {
          "type": "value",
          "name": "println",
          "signature": "(String) -> Task<Unit>"
        },
        {
          "type": "value",
          "name": "print",
          "signature": "(String) -> Task<Unit>"
        },
        {
          "type": "value",
          "name": "readline",
          "signature": "Task<String>"
        },
        {
          "type": "value",
          "name": "exit",
          "signature": "(Int) -> a"
        }
      ]
    },
    "Set": {
      "moduleName": "Set",
      "items": [
        {
          "type": "adt",
          "name": "Set",
          "params": [
            "a"
          ]
        },
        {
          "type": "value",
          "name": "empty",
          "signature": "Set<a>"
        },
        {
          "type": "value",
          "name": "member",
          "signature": "(Set<a>, a) -> Bool"
        },
        {
          "type": "value",
          "name": "insert",
          "signature": "(Set<a>, a) -> Set<a>"
        },
        {
          "type": "value",
          "name": "is_empty",
          "signature": "(Set<a>) -> Bool"
        },
        {
          "type": "value",
          "name": "reduce_right",
          "signature": "(Set<a>, b, (a, b) -> b) -> b",
          "docComment": " Fold over the values in a set, in order from highest to lowest.\n"
        },
        {
          "type": "value",
          "name": "size",
          "signature": "(Set<a>) -> Int"
        },
        {
          "type": "value",
          "name": "to_list",
          "signature": "(Set<a>) -> List<a>"
        }
      ]
    },
    "Time": {
      "moduleName": "Time",
      "items": [
        {
          "type": "value",
          "name": "now",
          "signature": "Task<Int>"
        }
      ]
    }
  }
}